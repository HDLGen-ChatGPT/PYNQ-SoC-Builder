-- Title Section Start
-- Generated by HDLGen, Github https://github.com/HDLGen-ChatGPT/HDLGen-ChatGPT, on 04-March-2024 at 22:20

-- Component Name : RISCV_ALU
-- Title          : RV32I RISC-V Arithmetic Logic Unit (ALU)

-- Author(s)      : Fearghal Morgan
-- Organisation   : University of Galway
-- Email          : fearghal.morgan@universityofgalway.ie
-- Date           : 04/03/2024

-- Description
-- RISC-V Arithmetic Logic Unit (RISCV_ALU) 
-- 
-- Combinational logic component
-- Input signal selALUOp(3:0) selects ALU function.
-- 32-bit data inputs A, B
-- 32-bit data output ALUOut
-- Output signal branch, asserted when branch condition is true

-- entity signal dictionary
-- selALUOp	ALU control signal
-- A	ALU data input A
-- B	ALU data input B
-- ALUOut	ALU data output
-- branch	Asserted (h) for branch operation (selALOp(3:0) = 10-15, if 
-- branch condition check is true

-- internal signal dictionary
-- None

-- Title Section End
-- library declarations
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.MainPackage.all;

-- entity declaration
entity RISCV_ALU is 
Port(
	selALUOp : in std_logic_vector(3 downto 0);
	A : in std_logic_vector(31 downto 0);
	B : in std_logic_vector(31 downto 0);
	ALUOut : out std_logic_vector(31 downto 0);
	branch : out std_logic
);
end entity RISCV_ALU;

architecture Combinational of RISCV_ALU is
-- Internal signal declarations
-- None

begin

ALUOut_p: process(selALUOp,A,B)
begin
	ALUOut <= (others => '0');-- Default assignment 
	
	case to_integer(unsigned(selALUOp)) is
		when 0 =>
			ALUOut <= std_logic_vector(signed(A) + signed(B));
		when 1 =>
			ALUOut <= std_logic_vector(signed(A) - signed(B));
		when 2 =>
			ALUOut <= A and B;
		when 3 =>
			ALUOut <= A or B;
		when 4 =>
			ALUOut <= A xor B;
		when 5 =>
			ALUOut <= std_logic_vector(shift_left(unsigned(A), to_integer(unsigned(B(4 downto 0)))));
		when 6 =>
			ALUOut <= std_logic_vector(shift_right(unsigned(A), to_integer(unsigned(B(4 downto 0)))));
		when 7 =>
			ALUOut <= std_logic_vector(shift_right(signed(A), to_integer(unsigned(B(4 downto 0)))));
		when 8 =>
			if signed(A) < signed(B) then
				ALUOut <= "00000000000000000000000000000001";
			end if;
		when 9 =>
			if unsigned(A) < unsigned(B) then
				ALUOut <= "00000000000000000000000000000001";
			end if;
		when others =>
			null;
	end case;
end process;

branch_p: process(selALUOp,A,B)
begin
	branch <= '0';-- Default assignment 
	
	case to_integer(unsigned(selALUOp)) is
		when 10 =>
			if unsigned(A) = unsigned(B) then
				branch <= '1';
			end if;
		when 11 =>
			if unsigned(A) /= unsigned(B) then
				branch <= '1';
			end if;
		when 12 =>
			if signed(A) < signed(B) then
				branch <= '1';
			end if;
		when 13 =>
			if signed(A) >= signed(B) then
				branch <= '1';
			end if;
		when 14 =>
			if unsigned(A) < unsigned(B) then
				branch <= '1';
			end if;
		when 15 =>
			if unsigned(A) >= unsigned(B) then
				branch <= '1';
			end if;
		when others =>
			null;
	end case;
end process;

end Combinational;
